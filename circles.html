<html>
<head>
<script>
        // https://github.com/mrdoob/three.js/wiki/How-to-run-things-locally
        // https://github.com/cmisenas/canny-edge-detection

        // { Canvas
        function Canvas(id, w, h, res) {
            this.elem = document.getElementById(id);
            this.width = w || 600;
            this.height = h || 400;
            if (this.elem === null) {
                this.elem = document.createElement('canvas');
                this.elem.id = id;
                this.elem.width = this.width;
                this.elem.height = this.height;
                document.body.insertBefore(this.elem, document.body.firstChild);
            }
            this.ctx = this.elem.getContext('2d');
            this.images = [];
            this.currentImg = {};

            var resizable = res || true;
            if (resizable === true) {
                this.elem.onmouseover = this.resize;
                this.elem.onmouseout = function() {
                    this.style.cursor = 'auto';
                };
            }
        }

        Canvas.prototype.resize = function(e) {
        if (e.pageX === this.offsetLeft && e.pageY !== this.offsetTop) {
                this.style.cursor = 'w-resize';
            } else if (e.pageX !== this.offsetLeft && e.pageY === this.offsetTop) {
                this.style.cursor = 'n-resize';
            } else if (e.pageX === this.offsetLeft + this.width - 1 && e.pageY !== this.offsetTop + this.height - 1) {
                this.style.cursor = 'e-resize';
            } else if (e.pageX !== this.offsetLeft + this.width - 1 && e.pageY === this.offsetTop + this.height - 1) {
                this.style.cursor = 's-resize';
            }
        };

        Canvas.prototype.loadImg = function(img, sx, sy) {
            this.images.push(img);
            this.currentImg.index = this.images.indexOf(img);

            var that = this;
            var usrImg = new Image();
            usrImg.onload = function() {
                if (usrImg.width !== that.width || usrImg.height !== that.height) {
                    that.width = usrImg.width;
                    that.height = usrImg.height;
                    that.elem.width = that.width;
                    that.elem.height = that.height;
                }
                that.ctx.drawImage(usrImg, sx || 0, sy || 0);
                that.currentImg.imgData = that.ctx.getImageData(0, 0, that.elem.width, that.elem.height);
                if (that.onImageLoaded) {
                    that.onImageLoaded();
                }
            };
            usrImg.src = img;
            return this;
        };

        Canvas.prototype.runImg = function(size, fn) {
            var that = this;

            for (var y = 0; y < this.height; y++) {
                for (var x = 0; x < this.width; x++) {
                    var i = x * 4 + y * this.width * 4;
                    var matrix = getMatrix(x, y, size);
                    fn(i, matrix);
                }
            }

            function getMatrix(cx, cy, size) {//will generate a 2d array of size x size given center x, center y, size, image width & height
                var matrix = [];
                for (var i = 0, y = -(size-1)/2; i < size; i++, y++) {
                    matrix[i] = [];
                    for (var j = 0, x = -(size-1)/2; j < size; j++, x++) {
                        matrix[i][j] = (cx + x) * 4 + (cy + y) * that.width * 4;
                    }
                }
                return matrix;
            }
        };

        Canvas.prototype.copyImageData = function(src) {
            var dst = this.ctx.createImageData(src.width, src.height);
            dst.data.set(src.data);
            return dst;
        };

        Canvas.prototype.setPixel = function(i, val, imgData) {
            imgData.data[i] = typeof val == 'number'? val: val.r;
            imgData.data[i + 1] = typeof val == 'number'? val: val.g;
            imgData.data[i + 2] = typeof val == 'number'? val: val.b;
        };

        Canvas.prototype.getPixel = function(i, imgData) {
            if (i < 0 || i > imgData.data.length - 4) {
                return {r: 255, g: 255, b: 255, a: 255};
            } else {
                return {r: imgData.data[i], g: imgData.data[i + 1], b: imgData.data[i + 2], a: imgData.data[i + 3] };
            }
        };
        // } Canvas

        // { Canny
        function Canny(canvElem) {
            var canvas = canvElem;

            this.grayscale = function(imgData) {
                var imgDataCopy = canvas.copyImageData(imgData);
                console.time('Grayscale Time');
                canvas.runImg(null, function(current) {
                    var grayLevel = (0.3 * imgDataCopy.data[current]) + (0.59 * imgDataCopy.data[current + 1]) + (0.11 * imgDataCopy.data[current + 2]);
                    canvas.setPixel(current, grayLevel, imgDataCopy);
                });
                console.timeEnd('Grayscale Time');
                return imgDataCopy;
            };

            this.gaussianBlur = function(imgData, sigma, size) {
                var imgDataCopy = canvas.copyImageData(imgData);
                var that = this;
                var kernel = generateKernel(sigma, size);

                console.time('Blur Time');
                canvas.runImg(size, function(current, neighbors) {
                    var resultR = 0;
                    var resultG = 0;
                    var resultB = 0;
                    for (var i = 0; i < size; i++) {
                        for (var j = 0; j < size; j++) {
                            var pixel = canvas.getPixel(neighbors[i][j], imgData);
                            resultR += pixel.r * kernel[i][j];//return the existing pixel value multiplied by the kernel matrix
                            resultG += pixel.g * kernel[i][j];
                            resultB += pixel.b * kernel[i][j];
                        }
                    }
                    canvas.setPixel(current, {r: resultR, g: resultG, b: resultB}, imgDataCopy);
                });
                console.timeEnd('Blur Time');

                function generateKernel(sigma, size) {
                var matrix = [];
                var E = 2.718;//Euler's number rounded of to 3 places
                for (var y = -(size - 1)/2, i = 0; i < size; y++, i++) {
                    matrix[i] = [];
                    for (var x = -(size - 1)/2, j = 0; j < size; x++, j++) {
                        //create matrix round to 3 decimal places
                        matrix[i][j] = 1/(2 * Math.PI * Math.pow(sigma, 2)) * Math.pow(E, -(Math.pow(Math.abs(x), 2) + Math.pow(Math.abs(y), 2))/(2 * Math.pow(sigma, 2)));
                    }
                }
                //normalize the matrix to make its sum 1
                var normalize = 1/that.sum(matrix);
                for (var k = 0; k < matrix.length; k++) {
                    for (var l = 0; l < matrix[k].length; l++) {
                        matrix[k][l] = Math.round(normalize * matrix[k][l] * 1000)/1000;
                    }
                }
                return matrix;
                }

                return imgDataCopy;
            };

            this.sobel = function(imgData) {//find intensity gradient of image
                var imgDataCopy = canvas.copyImageData(imgData);
                var dirMap = [];
                var gradMap = [];
                //perform vertical convolution
                var xfilter =
                   [[-1, 0, 1],
                    [-2, 0, 2],
                    [-1, 0, 1]];
                //perform horizontal convolution
                var yfilter =
                   [[1, 2, 1],
                    [0, 0, 0],
                    [-1, -2, -1]];

                console.time('Sobel Filter Time');
                canvas.runImg(3, function(current, neighbors) {
                    var edgeX = 0;
                    var edgeY = 0;
                    if (checkCornerOrBorder(current, imgDataCopy.width, imgDataCopy.height) === false) {
                        for (var i = 0; i < 3; i++) {
                            for (var j = 0; j < 3; j++) {
                                edgeX += imgData.data[neighbors[i][j]] * xfilter[i][j];
                                edgeY += imgData.data[neighbors[i][j]] * yfilter[i][j];
                            }
                        }
                    }

                    var dir = roundDir(Math.atan2(edgeY, edgeX) * (180/Math.PI));
                    dirMap[current] = dir;

                    var grad = Math.round(Math.sqrt(edgeX * edgeX + edgeY * edgeY));
                    gradMap[current] = grad;

                    canvas.setPixel(current, grad, imgDataCopy);
                });
                console.timeEnd('Sobel Filter Time');

                function checkCornerOrBorder(i, width, height) {//returns true if a pixel lies on the border of an image
                    return i - (width * 4) < 0 || i % (width * 4) === 0 || i % (width * 4) === (width * 4) - 4  || i + (width * 4) > width * height * 4;
                }

                function roundDir(deg) {//rounds degrees to 4 possible orientations: horizontal, vertical, and 2 diagonals
                    deg = deg < 0 ? deg + 180 : deg;
                    var roundVal;
                    if ((deg >= 0 && deg <= 22.5) || (deg > 157.5 && deg <= 180)) {
                        roundVal = 0;
                    } else if (deg > 22.5 && deg <= 67.5) {
                        roundVal = 45;
                    } else if (deg > 67.5 && deg <= 112.5) {
                        roundVal = 90;
                    } else if (deg > 112.5 && deg <= 157.5) {
                        roundVal = 135;
                    }
                    return roundVal;
                }

                imgDataCopy.dirMap = dirMap;
                imgDataCopy.gradMap = gradMap;
                return imgDataCopy;
            };

            this.nonMaximumSuppress = function(imgData) {
                var imgDataCopy = canvas.copyImageData(imgData);
                console.time('NMS Time');
                canvas.runImg(3, function(current, neighbors) {
                    var pixNeighbors = getNeighbors(imgData.dirMap[current]);

                    //pixel neighbors to compare
                    var pix1 = imgData.gradMap[neighbors[pixNeighbors[0].x][pixNeighbors[0].y]];
                    var pix2 = imgData.gradMap[neighbors[pixNeighbors[1].x][pixNeighbors[1].y]];

                    if (pix1 > imgData.gradMap[current] || pix2 > imgData.gradMap[current]) {//suppress
                        canvas.setPixel(current, 0, imgDataCopy);
                    } else if (pix2 === imgData.gradMap[current] && pix1 < imgData.gradMap[current]) {
                        canvas.setPixel(current, 0, imgDataCopy);
                    }
                });
                console.timeEnd('NMS Time');

                function getNeighbors(dir) {
                    var degrees = {0 : [{x:1, y:2}, {x:1, y:0}], 45 : [{x: 0, y: 2}, {x: 2, y: 0}], 90 : [{x: 0, y: 1}, {x: 2, y: 1}], 135 : [{x: 0, y: 0}, {x: 2, y: 2}]};
                    return degrees[dir];
                }

                return imgDataCopy;
            };

            this.hysteresis = function(imgData, d){ //mark strong and weak edges, discard others as false edges; only keep weak edges that are connected to strong edges
                var that = this;
                return function() {
                    var imgDataCopy = canvas.copyImageData(imgData);
                    var realEdges = []; //where real edges will be stored with the 1st pass

                    var t2 = 127 - d; //low threshold value
                    var t1 = 127 + d; //high threshold value

                    //first pass
                    console.time('Hysteresis Time');
                    canvas.runImg(null, function(current) {
                        if (imgData.data[current] > t1 && realEdges[current] === undefined) {//accept as a definite edge
                            var group = that.traverseEdge(current, imgData, t2, []);
                            for(var i = 0; i < group.length; i++){
                                realEdges[group[i]] = true;
                            }
                        }
                    });

                    //second pass
                    canvas.runImg(null, function(current) {
                        if (realEdges[current] === undefined) {
                            canvas.setPixel(current, 0, imgDataCopy);
                        } else {
                            canvas.setPixel(current, 255, imgDataCopy);
                        }
                    });
                    console.timeEnd('Hysteresis Time');

                    return imgDataCopy;
                };
            };


            this.invertColors = function(imgData) {
                var imgDataCopy = canvas.copyImageData(imgData);
                console.time('Invert Colors Time');
                canvas.runImg(null, function(current) {
                    canvas.setPixel(current, {r: 255 - imgDataCopy.data[current], g: 255 - imgDataCopy.data[current + 1], b: 255 - imgDataCopy.data[current + 2]}, imgDataCopy);
                });
                console.timeEnd('Invert Colors Time');
                return imgDataCopy;
            };

            this.showDirMap = function(imgData) {//just a quick function to look at the direction results
                return function() {
                    var imgDataCopy = canvas.copyImageData(imgData);
                    canvas.runImg(null, function(i) {
                        if (imgData.dirMap[i] === 0) {
                            canvas.setPixel(i, {r: 255, g: 0, b: 0}, imgDataCopy);
                        } else if (imgData.dirMap[i] === 45) {
                            canvas.setPixel(i, {r: 0, g: 255, b: 0}, imgDataCopy);
                        } else if (imgData.dirMap[i] === 90) {
                            canvas.setPixel(i, {r: 0, g: 0, b: 255}, imgDataCopy);
                        } else if (imgData.dirMap[i] === 135) {
                            canvas.setPixel(i, {r: 255, g: 255, b: 0}, imgDataCopy);
                        } else {
                            canvas.setPixel(i, {r: 255, g: 0, b: 255}, imgDataCopy);
                        }
                    });
                    return imgDataCopy;
                };
            };

            this.showGradMap = function(imgData) {
                return function() {
                    var imgDataCopy = canvas.copyImageData(imgData);
                    canvas.runImg(null, function(i) {
                        if (imgData.gradMap[i] < 0) {
                            canvas.setPixel(i, {r: 255, g: 0, b: 0}, imgDataCopy);
                        } else if (imgData.gradMap[i] < 200) {
                            canvas.setPixel(i, {r: 0, g: 255, b: 0}, imgDataCopy);
                        } else if (imgData.gradMap[i] < 400) {
                            canvas.setPixel(i, {r: 0, g: 0, b: 255}, imgDataCopy);
                        } else if (imgData.gradMap[i] < 600) {
                            canvas.setPixel(i, {r: 255, g: 255, b: 0}, imgDataCopy);
                        } else if (imgData.gradMap[i] < 800) {
                            canvas.setPixel(i, {r: 0, g: 255, b: 255}, imgDataCopy);
                        } else {
                            canvas.setPixel(i, {r: 255, g: 0, b: 255}, imgDataCopy);
                        }
                    });
                    return imgDataCopy;
                };
            };

            //helper functions
            this.sum = function(arr) {//receives an array and returns sum
                var result = 0;
                for (var i = 0; i < arr.length; i++) {
                if (/^\s*function Array/.test(String(arr[i].constructor)))
                    {
                        result += this.sum(arr[i]);
                    } else {
                        result += arr[i];
                    }
                }
                return result;
            };

            this.traverseEdge = function(current, imgData, threshold, traversed) {//traverses the current pixel until a length has been reached
                var group = [current]; //initialize the group from the current pixel's perspective
                var neighbors = this.getNeighborEdges(current, imgData, threshold, traversed);//pass the traversed group to the getNeighborEdges so that it will not include those anymore
                for(var i = 0; i < neighbors.length; i++){
                    group = group.concat(this.traverseEdge(neighbors[i], imgData, threshold, traversed.concat(group)));//recursively get the other edges connected
                }
                return group; //if the pixel group is not above max length, it will return the pixels included in that small pixel group
            };


            this.getNeighborEdges = function(i, imgData, threshold, includedEdges) {
                var neighbors = [];
                var directions = [
                    i + 4, //e
                    i - imgData.width * 4 + 4, //ne
                    i - imgData.width * 4, //n
                    i - imgData.width * 4 - 4, //nw
                    i - 4, //w
                    i + imgData.width * 4 - 4, //sw
                    i + imgData.width * 4, //s
                    i + imgData.width * 4 + 4 //se
                ];
                for(var j = 0; j < directions.length; j++)
                  if(imgData.data[directions[j]] >= threshold && (includedEdges === undefined || includedEdges.indexOf(directions[j]) === -1))
                    neighbors.push(directions[j]);

                return neighbors;
            };

            this.getAllEdges = function(imgData) {
                var that = this;
                var traversed = [];
                var edges = [];
                console.time('Get Edges Time');
                canvas.runImg(null, function(current) {
                if (imgData.data[current] === 255 && traversed[current] === undefined) {//assumes that an edge has white value
                    var group = that.traverseEdge(current, imgData, 255, []);
                    edges.push(group);
                    for(var i = 0; i < group.length; i++){
                        traversed[group[i]] = true;
                    }
                }
                });
                console.timeEnd('Get Edges Time');
                return edges;
            };
        }
        // } Canny

        function getCircle(x, y, n, canvas) {
           var N = n;
           var s = {x:0, y:0, r:1};
           for (var i = 0;  i < N; ++i) {          
              s.x += x[i];
              s.y += y[i];
           }
           s.x /= N;
           s.y /= N;
           var err = 1e10;
           for(var u = 0; u < 400; ++u) {
             var A = [[0,0,0], [0,0,0], [0,0,0]];
             var b = [0,0,0];
             for (var i = 0;  i < N; ++i) {
                var xi = x[i], yi = y[i];
                var dx = xi - s.x, dy = yi - s.y;
                var dx2 = dx*dx, dy2 = dy*dy, dxdy = dx * dy;
                var R = Math.sqrt(dx2 + dy2);
                if (R == 0) R = 1;
                var R2 = R*R;
                var rR = s.r/R, dxR = dx/R, dyR = dy/R;
                var rR3 = rR/R2;
                A[0][0] += rR3*dx2 - rR + 1; A[0][1] += rR3*dxdy;         A[0][2] += dxR;
              /*A[1][0] = A[0][1];*/         A[1][1] += rR3*dy2 - rR + 1; A[1][2] += dyR;
              /*A[2][0] = A[0][2];*/       /*A[2][1] = A[1][2];*/       /*A[1][2] += 1;*/
                b[0] = (1 - rR) * dx;
                b[1] = (1 - rR) * dy;
                b[2] = R - s.r;
             }
             A[1][0] = A[0][1]; A[2][0] = A[0][2]; A[2][1] = A[1][2]; A[2][2] = N;

             var  determinant = +A[0][0]*[A[1][1]*A[2][2]-A[2][1]*A[1][2]]
                                -A[0][1]*[A[1][0]*A[2][2]-A[1][2]*A[2][0]]
                                +A[0][2]*[A[1][0]*A[2][1]-A[1][1]*A[2][0]];
             var invdet = 1/determinant;

             // invert transponed
             var r = [[0,0,0], [0,0,0], [0,0,0]];
             r[0][0] =  (A[1][1]*A[2][2]-A[2][1]*A[1][2])*invdet;
             r[1][0] = -(A[0][1]*A[2][2]-A[0][2]*A[2][1])*invdet;
             r[2][0] =  (A[0][1]*A[1][2]-A[0][2]*A[1][1])*invdet;
             r[0][1] = -(A[1][0]*A[2][2]-A[1][2]*A[2][0])*invdet;
             r[1][1] =  (A[0][0]*A[2][2]-A[0][2]*A[2][0])*invdet;
             r[2][1] = -(A[0][0]*A[1][2]-A[1][0]*A[0][2])*invdet;
             r[0][2] =  (A[1][0]*A[2][1]-A[2][0]*A[1][1])*invdet;
             r[1][2] = -(A[0][0]*A[2][1]-A[2][0]*A[0][1])*invdet;
             r[2][2] =  (A[0][0]*A[1][1]-A[1][0]*A[0][1])*invdet;

             var d = [
               r[0][0] * b[0] + r[0][1] * b[1] + r[0][2] * b[2],
               r[1][0] * b[0] + r[1][1] * b[1] + r[1][2] * b[2],
               r[2][0] * b[0] + r[2][1] * b[1] + r[2][2] * b[2],
             ];
             var newErr = d[0]*d[0] + d[1]*d[1] + d[2]*d[2];
             var scale  = 1;
             s.x += d[1];
             if (s.x < 0 || s.x > canvas.width) break;
             s.y += d[0];
             if (s.y < 0 || s.y > canvas.height) break;
             s.r += d[2];
             if (s.r < 0 || s.r > canvas.height/2 || s.r > canvas.width/2) break;
             if (u > 10 && newErr > err)
                break;
             err = newErr;    
           }
           if (s.r < 0) s.r = 1;
           console.log('x:' + s.x + ' y:' + s.y + ' r:' + s.r);
           return s;
        }

        function getSD(x, y, n, Nmin) {
	   var N = Nmin/3;
           var off1 = n - N*3;
           var off2 = n - N*2;
           var off3 = n - N;
           var x1 = 0, x2 = 0, x3 = 0; 
           var y1 = 0, y2 = 0, y3 = 0;
           for (var i = 0; i < N; ++i) {
             x1 += x[off1 + i]; y1 += y[off1 + i];
             x2 += x[off2 + i]; y2 += y[off2 + i];
             x3 += x[off3 + i]; y3 += y[off3 + i];
           }
           x1 /= N; x2 /= N;  x3 /= N;
           y1 /= N; y2 /= N;  y3 /= N;
           if (x2 == x1 || x3 == x2 || x3 == x1) return 10000;
           return 2*((y3 - y2)/(x3 - x2) - (y2 - y1)/(x2 - x1))/(x3 - x1);
        }

        function init() {
            new Canvas("image").loadImg("test.jpg").onImageLoaded = function() {
                var canvas = this;
                var canny = new Canny(this);
                var currentImgData = canvas.ctx.getImageData(0, 0, canvas.elem.width, canvas.elem.height);
                currentImgData = canny.grayscale(currentImgData);
                var newImgData = canny.nonMaximumSuppress(canny.sobel(currentImgData));

                newImgData = canny.hysteresis(newImgData, parseInt(document.getElementById("d").value))();
                //canvas.ctx.putImageData(newImgData, 0, 0);

                var al = canny.getAllEdges(newImgData);
                var r = 2;
                var wightLimitLow = (r + 1) ; //cross only!
                var wightLimitUp = wightLimitLow * 2; //cross only!
                var Nmax = 100;
                var Nmin = 3*9;
                var SD_DIV = 0.7;
                var _x = new Array(Nmax);
                var _y = new Array(Nmax);
                var lineSize = canvas.width*4;
                for(var i = 0; i < al.length; ++i){
                    var adge = al[i];
                    var color = {r:Math.random()*255, g:Math.random()*255, b:Math.random()*255};
                    canvas.ctx.strokeStyle = "rgb("
                      + (~~(Math.random()*255)) + ","
                      + (~~(Math.random()*255)) + ","
                      + (~~(Math.random()*255)) + ")";

                    var n = 0;
                    var sdOld = 0;
                    for(var k = 0; k < adge.length; ++k) {
                          var pos = adge[k];
                          _x[n] = (pos % lineSize) / 4;
                          _y[n] = ~~(pos / lineSize);
                          ++n;
                          var sdDiv;
                          if (n < Nmin) {
                            sdDiv = 0;
                          } else if (n == Nmin) {
                            var sd = getSD(_x, _y, n, Nmin);
                            sdOld = sd * n;
                            sdDiv = 0;
                          } else { // n > Nmin
                            var sd = getSD(_x, _y, n, Nmin);

                            var sdM = (sdOld + sd)/n;
                            var sdMold = sdOld/(n - 1);
                            sdDiv = (sdM - sdMold)/sdM;
                            if (sdDiv < 0) sdDiv = -sdDiv;

                            sdOld += sd;
                          }
                          canvas.ctx.beginPath();
                          canvas.ctx.moveTo(_x[n],_y[n]);
                          canvas.ctx.lineTo(_x[n]+1,_y[n]+1);
                          canvas.ctx.stroke();
                          if (n >= Nmax || sdDiv >= SD_DIV) {
                             // find the circle
                             var circle = getCircle(_x, _y, n, canvas);
                             if (circle && circle.r > 5 && circle.r < 50) {
                                canvas.ctx.beginPath();
                                canvas.ctx.arc(circle.x, circle.y, circle.r, 0, 2*Math.PI);
                                canvas.ctx.stroke();
                             }
                             color = {r:Math.random()*255, g:Math.random()*255, b:Math.random()*255};
                             canvas.ctx.strokeStyle = "rgb("
                              + (~~(Math.random()*255)) + ","
                              + (~~(Math.random()*255)) + ","
                              + (~~(Math.random()*255)) + ")";
                             n = 0;
                             sdOld = 0;  
                          }
                          //canvas.setPixel(pos, color, newImgData);
                          //canvas.ctx.strokeStyle = "#00ff00";
                    }
                }
                //canvas.ctx.putImageData(newImgData, 0, 0);
            };
        }

</script>
</head>
<body onload="init();">
<canvas id="image">
</canvas>
<input id="d" type="edit" value="90"/><button onclick="init()">Redraw</button>
</body>
</html>
